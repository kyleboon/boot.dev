Preparing for the next 20 years
I'm 42 years old and I've been programming since I was 12 or 13 years old. I taught myself QBasic when my family bought a computer when I was in the 6th grade, somewhere around 1994. I was really into Estes model rockets and I wanted to write a program that could calculate apogee and other rocketry related things. I didn't really understand loops or functions and so I used goto statements for pretty much all control flow. I was 12 so I hadn't read Goto considered harmful yet. 
I quickly became more interested in computers than rockets and spent time installing Linux (installing Slackware in the mid 90s required almost as much effort as installing Arch linux today) and learning as much as I could. I built bad websites using nested tables and cgi-bin scripts written in perl. I got my first programming job after my Jr year of high school writing ASP that was littered in sql injection bugs. In 1999, the SQL Injection attack had only been discovered the year prior and I don't think very may high school students had ever heard of it.
The point is I've been programming for a long time, and other than working at Mcdonald's through most of high school, it's the only thing I've ever done to put food on the table. I've gotten fairly good at programming, although, maybe not as good I should be considered how much I've done it. For the past few years I've been a staff engineer which is a job that requires excellent technical judgement, acquired through years of experience, but at the same time I don't spend nearly as much time programming as I used to. 
I'm nervous that my technical skills are not what they used to be. They certainly aren't as broad as they used to be. In my chosen niche - backend software on the JVM - I'm still very much an expert. However, I haven't written production javascript since Angular 1.x. I've never learned go or rust. I've done some python but I still haven't committed to memory that in python I need to append and expand a list and not add or addAll . Honestly that's python's fault though, what made them use expand ? 
I want to continue to be a programmer until I retire. I reserve the right to change my mind, but my interest in being a people manager is pretty low. Too many of my friends have told me about the HR issues they have to deal with. They say never meet your heros, but it's also better to never find out the terrible shit your coworkers have done, if you have to keep working with them. 
So, I've been putting a lot of thought into what I need to do to be able to keep my good engineering judgement and widen my engineering skillset again. During the pandemic I started playing chess semi seriously again for the first time since I was a kid. One piece of advice I was given was to concentrate on my weak spots. Instead of leaning into my strengths, the path to improvement is to raise up the weakest parts of my game. It doesn't matter if you're capable of brilliance if you're more likely to make a blunder. 
I think this is a good strategy for programming improvement too. For me this means:
Learn or relearn more programming languages. I need to be comparably as proficient at Javascript (not React necessarily) as a senior engineer. I need to know python much better, at least in my organization java, javascript and python are the most commonly used languages. I want to learn go, my intuition that a lot of the types applications that were built on the JVM over the last 10 years are going to be done in go in the next 10. Go has the huge advantage over java in that spring boot doesn't exist for it. 
Refresh my memory on data structures and algorithms. Of course I still know what a queue and a stack are - but I haven't implemented a binary tree or djikstra's algorithm since college. I don't need to have these committed to memory to be an effective programmer, but the act of implementing them does make you a better programmer. 
Start reading software engineering books again. I think I stopped doing this regularly when my first kid was born(almost 8 years ago!). My free time suddenly became very limited and when I did have time to read, I wanted to read for pleasure and not difficult technical texts. I did start a book club at work and we've gone though Domain Driven Design, Designing Data Intensive Applications (both rereads for me) and now we're reading Software Architecture: The Hard Parts and I've really been enjoying it. 
Build some complex projects outside of work. This is the one I haven't started doing yet. There are things I'm interested in building as learning projects. I want to build a chess engine. I want to build a (toy) distributed key-value store. I want to build a compiler and a simple operating system. 

In the story (parable?) of the two woodcutters, two men compete to see who can chop down more trees. One starts chopping immediately and starts piling up logs as the other sits down and begins to sharpen his ax. tldr; The man who sharpened his ax first won. I know that I want to keep programming for the rest of my career, so now I just need to make sure I take time to sharpen the ax from time to time.